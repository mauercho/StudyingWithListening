package com.ssafy.a304.shortgong.global.util;

import java.io.IOException;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.web.client.RestTemplate;

@SpringBootTest
class EmbeddingUtilTest {

	@Autowired
	private RestTemplate restTemplate;

	@Test
	void getTextEmbedding() throws IOException {

		EmbeddingUtil embeddingUtil = new EmbeddingUtil(restTemplate);
		// embeddingUtil.setApiUrl();
		// embeddingUtil.setAuthFilePath();

		double[] response = embeddingUtil.getTextEmbedding(
			"공부란 스키마로 해석‧재구성해 새로운 스키마를 만드는 것\n"
				+ "새로운 지식은 기존의 지식을 통해 습득된다. 사람은 기존의 지식을 근거로 새로운 지식을 이해하고 해석한다. 사실적 지식들이 개념화돼 개념적 지식을 만들게 되면, 이 개념 지식은 새로운 경험들을 해석하고 구성해 스키마 체계에 넣게 된다.\n"
				+ "만약 지식이 없다면 새로운 지식은 매우 낯설어, 이해하기 어려울 것이다. 이 지식을 기억하기 위한 유일한 방법은 반복일 것이다. 하지만 반복해서 기억하는 것으로는 부족하다. 반복 학습을 통해 새로운 스키마를 만들어야 제대로 공부를 했다고 할 수 있는 것이다.\n"
				+ "반복을 통해 새로운 지식을 개념화하는 과정은 저절로 이뤄지지 않기 때문에 의도적으로 노력해야한다. 하지만 사전 지식이 있음에도 불구하고 새로운 지식을 반복해 학습하는 것은 매우 어리석은 일이다. 새로운 지식을 기존의 지식으로 이해하고 체계화하는 것이 가장 효율적인 방법이다. 새로운 지식을 학습할 때는 먼저 자신의 지식을 탐색해 가장 관계있는 스키마로 이해해야한다. 결국 공부란 스키마로 해석하고 재구성해 새로운 스키마를 만드는 것이다.\n"
				+ "‘민주주의’란 개념을 대했을 때, 이 말을 처음 들었다 하더라도 이미 갖고 있는 한글에 대한 지식을 바탕으로 이 글을 읽게 된다. 비록 의미는 모르더라도 글씨를 읽을 수 있는 것은 이미 갖고 있는 지식으로 해석했기 때문이다. 따라서 ‘민주주의’와 ‘민주주의’, ‘민주주의’, ‘민주주의’는 비록 글자체는 다르지만 모두 같은 의미로 받아들인다.\n"
				+ "또 세상에 있는 모든 사람은 생김새가 다 다르다. 비록 일란성 쌍둥이라 하더라도 가족들은 구별할 수 있다고 하니 생김새가 같은 사람은 없다고 할 수 있겠다. 그런데 우리는 어떤 사람을 보더라도 상대가 사람이라는 것을 안다. 그럼 어떻게 알 수 있을까? 그 이유는 우리가 이미 갖고 있는 ‘사람’이라는 개념으로 해석했기 때문이다. 이와 같이 사람은 어떤 경험을 그대로 받아들이는 것이 아니라, 자신이 지니고 있는 지식, 즉 스키마로 해석하고 재구성해 받아들인다.\n"
				+ "공부란 새로운 경험을 받아들이는 것이라 할 수 있다. 그런데 새로운 경험을 있는 그대로 받아들이지 못하고 반드시 해석하고 재구성해 받아들인다. 따라서 공부를 잘하기 위해서는 잘 해석하고, 재구성하는 것이 중요하다.\n"
				+ "잘 해석하고 재구성하는 것이 중요\n"
				+ "그렇다면 어떻게 해석해야 할까? 학생들이 공부하는 것을 대상으로 삼아 생각해보자. 우선 우리가 배우는 것은 거의 언어로 표시된 개념적인 지식이라 할 수 있다. 그런데 어떤 언어에 대해 갖고 있는 개념은 사람마다 모두 다를 수 있다.\n"
				+ "예를 들어 ‘민주주의’라는 언어에 대해 갖고 있는 개념은 사람마다 모두 다를 수 있다는 것이다. 그리고 사람들은 자신의 개념으로 새로운 지식을 해석한다고 했다. 따라서 새로운 지식을 통해 형성된 언어에 대한 개념과 그것을 배우는 사람들이 지닌 개념이 다를 수 있게 된다.\n"
				+ "만약 이러한 상황에서 새로운 지식을 해석한다면 필연적으로 잘못 해석할 가능성이 높다. 그러므로 새로운 지식을 공부할 때, 그 지식에서 사용한 개념과 자신이 지니고 있는 개념을 일치시키는 것이 가장 중요하다. 즉 새로운 지식에 대한 이해를 먼저 해야 하는 것이다.\n"
				+ "새로운 지식을 공부하기 위해서는 그 지식에서 사용하는 개념의 정확한 의미를 이해한 뒤, 그 의미를 가지고 해석하는 것이 중요하다. 만약 그렇게 하지 않으면 잘못된 해석을 할 수 있기 때문이다. 이런 면에서 공부란 기존의 지식을 새롭게 하는 과정이라고도 할 수 있다.\n"
				+ "만약 어떤 사람이 이러한 이해나 해석을 하지 않고 공부를 한다면, 그것은 단지 글씨 공부를 하고 있는 것에 불과하다. 마치 처음 글자를 배운 어린이가 그 의미는 전혀 생각하지 않고 읽는 것과 같다고 할 수 있다. 사람은 의식하지는 못하지만 새로운 지식을 공부할 때에는 어떤 식으로든 해석하고 재구성한다고 볼 수 있다.");

		double[] response2 = embeddingUtil.getTextEmbedding("T: 공부와 스키마의 관계\n"
			+ "\n"
			+ "- P: 스키마를 통한 지식 습득\n"
			+ "Q: 스키마란 무엇이며, 새로운 지식을 습득하는 과정에서 어떤 역할을 하나요?\n"
			+ "A: 스키마는 우리가 이미 가지고 있는 지식 체계를 의미합니다. 새로운 지식을 접할 때, 우리는 이 기존 스키마를 통해 그것을 이해하고 해석합니다. 예를 들어, 처음 보는 글자체의 '민주주의'라는 단어를 읽을 수 있는 것은 우리가 이미 한글에 대한 스키마를 가지고 있기 때문입니다.\n"
			+ "- P: 효과적인 공부 방법\n"
			+ "Q: 단순 반복 학습과 스키마를 활용한 학습의 차이점은 무엇인가요?\n"
			+ "A: 단순 반복 학습은 의미 없는 암기에 그치지만, 스키마를 활용한 학습은 새로운 지식을 기존 지식과 연결하여 체계화하는 과정입니다. 특히 사전 지식이 있는 상태에서 단순 반복 학습을 하는 것은 매우 비효율적입니다. 대신 새로운 지식을 기존 스키마로 이해하고 재구성하는 것이 가장 효과적인 방법입니다.\n"
			+ "\n"
			+ "T: 지식의 이해와 해석\n"
			+ "\n"
			+ "- P: 개념의 올바른 이해\n"
			+ "Q: 새로운 지식을 공부할 때 가장 중요한 것은 무엇인가요?\n"
			+ "A: 새로운 지식에서 사용하는 개념의 정확한 의미를 먼저 이해하는 것이 가장 중요합니다. 같은 단어라도 사람마다 다른 개념을 가질 수 있기 때문에, 새로운 지식에서 사용하는 개념과 자신이 가진 개념을 일치시키는 것이 필수적입니다. 그렇지 않으면 잘못된 해석을 할 수 있습니다.\n"
			+ "- P: 진정한 공부의 의미\n"
			+ "Q: 진정한 의미의 공부란 무엇인가요?\n"
			+ "A: 진정한 의미의 공부란 단순히 글자를 읽는 것이 아니라, 새로운 지식을 기존의 스키마로 해석하고 재구성하여 새로운 스키마를 만드는 과정입니다. 마치 어린이가 단순히 글자를 읽는 것과 그 의미를 이해하는 것의 차이처럼, 진정한 공부는 내용에 대한 깊은 이해와 해석을 포함합니다.\n"
			+ "\n"
			+ "T: 경험과 지식의 관계\n"
			+ "\n"
			+ "- P: 경험의 해석과 재구성\n"
			+ "Q: 우리가 경험을 통해 지식을 얻는 과정은 어떻게 이루어지나요?\n"
			+ "A: 우리는 경험을 있는 그대로 받아들이지 않고, 항상 기존의 스키마를 통해 해석하고 재구성합니다. 예를 들어, 모든 사람의 생김새가 다르지만 우리가 누군가를 '사람'이라고 인식할 수 있는 것은 이미 가지고 있는 '사람'이라는 스키마로 해석하기 때문입니다. 이처럼 새로운 경험은 항상 기존 지식을 통해 재해석되고 재구성됩니다.");

		double dotProduct = 0.0;
		double normA = 0.0;
		double normB = 0.0;
		for (int i = 0; i < response.length; i++) {
			dotProduct += response[i] * response2[i];
			normA += Math.pow(response[i], 2);
			normB += Math.pow(response2[i], 2);
		}
		System.out.print(dotProduct / (Math.sqrt(normA) * Math.sqrt(normB)));

	}
}

