package com.ssafy.a304.shortgong.global.util;

import java.util.Arrays;

import org.springframework.stereotype.Component;

import com.ssafy.a304.shortgong.global.model.dto.CacheMessageContent;

@Component
public class PromptUtil {

	private final static int count = 10;
	private final static int tCount = 2;
	private final static int qCount = 4;

	/**
	 * TPQ 프롬프트를 생성합니다.
	 */
	public String TPQ(String text) {

		return String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 본문 텍스트를 명확하고 간결하게 요약하는 데 특화되어 있다. 주어진 본문을",
			" 읽고 사용자가 TTS로 듣기만 해도 학습적, 교육적, 암기적 효과를 얻을 수 있는 팟캐스트 형식의 TPQ 스크립트를 작성해 주세요.\n\n",
			"반환 데이터는 T(Title), P(Point), Q(Question)로 구성된 QA 형식의 스크립트여야 하며, 이 형식은 학습과 암기에 효과적일 수 있도록 단순하고 명확하게 구성되어야 합니다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성해 주세요.",

			"각 질문은 간결하고 핵심적인 개념을 포함해야 하며, 암기 효과를 극대화하기 위해 반복과 중요 개념의 강조가 필요합니다. ",
			"질문과 포인트는 사용자가 자연스럽게 연결될 수 있도록 구성하고, 각 주제에 대한 요점을 이해할 수 있도록 명확히 설정해 주세요.\n\n",

			"TPQ 형식의 텍스트에 포함될 것:\n",
			"- 대제목(T): 각 대화의 주요 주제를 포괄적이지만 핵심적으로 나타내 주세요.\n",
			"- 포인트(P): 각 질문(Q)의 앞에서, 대화에서 다루는 세부 주제 및 키워드를 명확히 설정해 주세요. 핵심 개념이 강조되도록 간결하게 작성해 주세요.\n",
			"- 질문(Q): 각 대화 주제에 대한 질문을 명확하고 간결하게 작성한다. 핵심 개념을 포함하며, 사용자가 쉽게 이해하고 기억할 수 있도록 구성해 주세요.\n",

			"**공통 요구 사항**\n",
			"- 간결한 질문: 모든 질문은 간결하면서도 학습적 가치를 극대화할 수 있도록 작성하며, 사용자가 이해하기 쉽고 기억에 잘 남도록 구성해 주세요. 광범위한 Answer가 나올 질문보다는, 특정한 주제 하나로 답변이 나올 수 있도록 해 주세요.\n",
			"- TPQ 형식의 질문 구성: 각 질문은 본문에서 중요하거나 핵심적인 개념을 다루어야 하며, 사용자가 학습 내용을 쉽게 기억할 수 있도록 작성해 주세요. 특정한 키워드 1~2개를 Answer로 답할 수 있는 질문을 내 주세요.\n",
			"- 사용자가 TTS로 들을 때 이해하기 쉬운 리듬과 구조를 제공한다.\n", // 듣기 쉬운 대본
			"- 주제와 포인트 명확화: 각 질문(Q) 앞에는 P로 시작하는 포인트(P)를, 각 대화 주제 앞에는 T로 시작하는 타이틀(T)을 사용하여, 주제를 명확히 설정해 주세요.\n",
			// 주제와 포인트 명확화
			"- 단일 주제 그룹화: 비슷한 주제의 질문은 반드시 하나의 대제목(T)에 묶어 주세요. 즉, 질문은 반드시 하나의 T에 소속되게 해 주세요.\n",
			"- 영어 알파벳을 제외한 일본어, 중국어와 같은 외국어 및 한자 등을 포함하여 반환하지 말아 주세요.\n",
			"- T와 P와 Q를 기준으로, 하나의 개행문자(\\n)로 나누어 응답해 주세요.\n",
			"- \"다른 표현 방식들\"과 같은 추가적인 표현 방식이나 \"이 TPQ의 작성 이유는 다음과 같습니다:\"와 같은 프롬프트 설명 멘트를 포함하여 반환하지 말아 주세요.\n",

			"대본의 예시:\n",
			"T: 데이터 무결성\n",
			"P: DBMS의 데이터 무결성 유지 방법\n",
			"Q: DBMS는 어떻게 데이터 무결성을 유지하나요?\n",
			"P: 데이터베이스 무결성 종류\n",
			"Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\n",
			"P: 참조 무결성이란?\n",
			"Q: 참조 무결성에 대해서 설명해 주세요.\n",
			"P: 참조 무결성 깨짐의 예시\n",
			"Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\n",
			"T: 암기\n",
			"P: 단순 암기와 진정한 공부의 차이점\n",
			"Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\n",

			"이제 주어진 본문 텍스트로 TPQ를 생성해 주세요. 입력 본문 텍스트는 다음과 같다.\n",
			"--------------------------------\n", text, "\n--------------------------------\n\n",
			"T는 " + tCount + "개를 제공하고, 각각 PQ를 " + qCount + "개, " + (qCount - 1) + "개로 제공해 주세요."
			// "이제 주어진 본문 텍스트를 요약하라. 입력 본문 텍스트는 다음과 같다.\n"
			// "--------------------------------\n", text,
			// "\n--------------------------------\n\nQA는 " + count + "가지로 제공하라."
		));
	}

	/**
	 * Keyword만으로도 TPQ 프롬프트를 생성합니다.
	 */
	public String getKeywordTPQ(String keyword) {

		return String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 키워드를 바탕으로 학습에 효과적인 TPQ 스크립트를 작성해 주셔야 합니다.\n",
			"반환 데이터는 T(Title), P(Point), Q(Question)로 구성된 형식이어야 하며, 사용자가 해당 키워드에 대해 학습적인 효과를 극대화할 수 있도록 구성해 주세요.\n",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성해 주세요.\n",

			"TPQ 형식의 텍스트에 포함될 것:\n",
			"- 대제목(T): 입력된 키워드를 중심으로 주요 주제를 설정해 주세요. 간결하면서도 포괄적으로 주제를 요약해 주세요.\n",
			"- 포인트(P): 각 질문(Q)이 다루는 세부 주제 및 키워드를 명확히 설정해 주세요. 핵심 개념이 강조되도록 간결하게 작성해 주세요.\n",
			"- 질문(Q): 시험이나 면접 등에서 자주 다뤄지는 키워드의 핵심 개념이나 외워야 할 부분에 대한 질문을 명확하고 간결하게 작성해 주세요. ",
			"학습 및 암기에 용이하도록 작성해 주세요.\n",

			"**공통 요구 사항**\n",
			"- 간결한 질문: 모든 질문은 간결하면서도 학습적 가치를 극대화할 수 있도록 작성하며, 사용자가 이해하기 쉽고 기억에 잘 남도록 구성해 주세요. ",
			"광범위한 Answer가 나올 질문보다는, 특정한 주제 하나로 답변이 나오게 해 주세요.\n",
			"- TPQ 형식의 질문 구성: 각 질문은 본문에서 중요하거나 핵심적인 개념을 다루어야 하며, 사용자가 학습 내용을 쉽게 기억할 수 있도록 작성해 주세요. ",
			"특정한 키워드 1~2개를 Answer로 답할 수 있는 질문을 내 주세요\n",
			"- 사용자가 TTS로 들을 때 이해하기 쉬운 리듬과 구조를 제공해 주세요.\n", // 듣기 쉬운 대본
			"- 주제와 포인트 명확화: 각 질문(Q) 앞에는 P로 시작하는 포인트(P)를, 각 대화 주제 앞에는 T로 시작하는 타이틀(T)을 사용하여, 주제를 명확히 설정해 주세요.\n",
			// 주제와 포인트 명확화
			"- 단일 주제 그룹화: 비슷한 주제의 질문은 반드시 하나의 대제목(T)에 묶어 주세요. 즉, 질문은 반드시 하나의 T에 소속되게 해 주세요.\n",
			"- 영어 알파벳을 제외한 일본어, 중국어와 같은 외국어 및 한자 등을 포함하여 반환하지 말아 주세요.\n",
			"- T와 P와 Q를 기준으로, 하나의 개행문자(\\n)로 나누어 응답해 주세요.\n",
			"- \"다른 표현 방식들\"과 같은 추가적인 표현 방식이나 \"이 TPQ의 작성 이유는 다음과 같습니다:\"와 같은 프롬프트 설명 멘트를 포함하여 반환하지 말아 주세요.\n",

			"대본의 예시:\n",
			"T: 데이터 무결성\n",
			"P: DBMS의 데이터 무결성 유지 방법\n",
			"Q: DBMS는 어떻게 데이터 무결성을 유지하나요?\n",
			"P: 데이터베이스 무결성 종류\n",
			"Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\n",
			"P: 참조 무결성이란?\n",
			"Q: 참조 무결성에 대해서 설명해 주세요.\n",
			"P: 참조 무결성 깨짐의 예시\n",
			"Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\n",
			"T: 암기\n",
			"P: 단순 암기와 진정한 공부의 차이점\n",
			"Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\n",

			"이제 입력으로 TPQ를 생성해 주세요. 입력은 다음과 같다.\n",
			"--------------------------------\n", keyword, "\n--------------------------------\n\n",
			"T는 " + tCount + "개를 제공하고, 각각 PQ를 " + qCount + "개, " + (qCount - 1) + "개로 제공해 주세요."
		));
	}

	public CacheMessageContent getCacheAnswerPrompt(String TContent, String PContent, String QContent, String text) {

		// 1. 시스템 프롬프트 부분 (항상 동일)
		String systemPrompt = String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 본문 텍스트를 바탕으로 TPQ(Title, Point, Question)에 대한 답변을 작성하는 데 특화되어 있습니다. ",
			"반환 데이터는 각 질문(Q)에 대해 A(Answer)를 Simple, Normal의 세 가지 버전으로 작성해 주세요.\n\n",
			"이 형식으로 출력된 데이터는 사용자가 학습 내용을 단계적으로 깊이 이해하고 암기할 수 있도록 구성되어야 합니다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성해 주세요. ",
			"또한, 면접장에서 정답 답변을 말할 수 있도록 확실한 정답을 포함해 주세요.\n",
			"사용자가 암기하기 쉽도록 구성된 내용을 대화 형태로 전달하고, 중요한 주제와 개념을 포함하는 질문과 답변 형식으로 작성해 주세요.\n\n",

			"2가지 Answer 형식에 대해 다음과 같은 형식을 지킬 것:\n",
			getSimpleAnswerRequirements(),
			getNormalAnswerRequirements(),
			getCommonAnswerRequirements()
		));

		// 2. 예시 부분 (항상 동일)
		String examplePrompt = String.join("", Arrays.asList(
			"입력되는 TContent, Pcontent, Qcontent와 출력되어야 하는 SA, NA의 예시:\n",

			"\"T: 데이터 무결성 P: 데이터베이스 무결성 종류 Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\"일 때,\n",
			"SA: 개체 무결성! 참조 무결성!\n",
			"NA: 데이터베이스 무결성에는 개체 무결성과 참조 무결성이 있어! ‘개참’이라는 단어로 기억해봐. 개체는 고유함, 참조는 관계 유지라는 키워드를 기억해!! 개참개참~\n",
			"\"T: 데이터 무결성 P: 참조 무결성이란? Q: 참조 무결성에 대해서 설명해 주세요.\"일 때,\n",
			"SA: 외래 키는 기본 키 참조!\n",
			"NA: 참조 무결성은 외래 키가 다른 테이블의 기본 키를 반드시 참조해야 한다는 규칙이야. 부모와 자식의 관계처럼, 자식-외래 키는 반드시 부모-기본 키가 있어야 해. 부모가 있어야 자식이 존재할 수 있는 거랑 똑같아!\n",
			"\"T: 데이터 무결성 P: 참조 무결성 깨짐의 예시 Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\"일 때,\n",
			"SA: 참조 대상 기본 키 삭제했을 때!\n",
			"NA: 참조 무결성은 외래 키가 참조하는 기본 키가 삭제되면 깨져. 아이가 부모를 찾으려고 하는데 부모가 갑자기 사라지면 당황스럽겠지? 자식인 외래 키는 어디로 가야 할지 모르게 되고, 관계가 단절되는 거지.\n",
			"\"T: 암기 P: 단순 암기와 진정한 공부의 차이점 Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\"일 때,\n",
			"SA: 쉽게 잊혀지기 vs 이해하고 응용하며 오래 기억하기\n",
			"NA: 단순 암기는 반복해서 외우는 거고, 진정한 공부는 이해하고 응용하는 거야. 단순 암기는 쉽게 잊혀지지만, 진정한 공부는 오래 남게 돼. 단순 암기가 벽돌을 하나씩 쌓는 거라면, 진정한 공부는 그 벽돌로 집을 짓는 거야. 집을 지어야 벽돌들이 의미를 가지듯이, 전체적인 그림을 그리며 이해하는 게 중요해.\n",
			"\"T: 정렬 P: 버블 정렬 Q: 버블 정렬은 무엇인가요?\"일 때,\n",
			"SA: 인접 비교 후 교환! 거품처럼 느림!\n",
			"NA: 거품처럼 느리게 올라간다! 버블 정렬은 인접한 두 개를 비교하며 교환해. 시간 복잡도는 O(n²)이야. 느리지만 쉬운 방식이야. 거품이 버블버블 터지는 소리를 상상해봐! 두 수를 바꿀 때마다 버블이 하나씩 터지는 거야.\n",
			"\"T: 정렬 P: 선택 정렬 Q: 선택 정렬은 무엇인가요?\"일 때,\n",
			"SA: 가장 작은 값 선택! 맨 앞 정렬!\n",
			"NA: 선택해서 뽑는다! 가장 작은 값을 찾아서, 맨 앞에 두는 거야~! 시간 복잡도는 O(n²)이야. 반복해서 선택하며 정렬해. 사람들이 줄 서 있는 걸 생각해봐! 가장 작은 키의 사람을 선택!해서! 앞으로 계속 보내는 것처럼!\n",
			"\"T: 정렬 P: 삽입 정렬 Q: 삽입 정렬은 무엇인가요?\"일 때,\n",
			"SA: 카드처럼 적절한 위치에 삽입!\n",
			"NA: 삽입! 카드를 한 장씩 올바른 위치에 삽입하듯 정렬해. 거의 정렬된 배열에서는 빠르게 O(n)이고, 최악의 경우 O(n제곱)이야. 카드들을 처음 받았을 때, 보기 편하게 손에 들고 있는 카드를 하나씩 적절한 자리에 삽입하는 걸 생각해봐!!\n",
			"\"T: 정렬 P: 퀵 정렬 Q: 퀵 정렬은 무엇인가요?\"일 때,\n",
			"SA: 피벗 선택, 분할 정렬. 평균 O(n log n), 최악 O(n²)\n",
			"NA: 빠르게 퀵! 피벗을 선택해, 작은 건 왼쪽, 큰 건 오른쪽으로 나눠. 평균 시간 복잡도는 O(n log n)이고, 최악의 경우 O(n²)이지만 보통은 빠르지. 피벗이라는 큰! 바위가 물줄기를 나누는 것처럼 데이터를 나누는 거야.\n",
			"\"T: 정렬 P: 병합 정렬 Q: 병합 정렬은 무엇인가요?\"일 때,\n",
			"SA: 반으로 나눠 병합! 평균 O(n log n). 안정적\n",
			"NA: 병합! 반으로 쪼개고, 다시 병합해. 분할 정복으로 평균 O(n log n)이고 항상 안정적인 친구야. 종이를 반으로 접고 다시 펴는 것처럼, 데이터를 나누고, 그 안에서 정렬하고 다시 합치는 거야.\n",
			"\"T: 정렬 P: 힙 정렬 Q: 힙 정렬은 무엇인가요?\"일 때,\n",
			"SA: 힙 구조 정렬! 산더미 쌓기! 평균 O(n log n)\n",
			"NA: 힙을 쌓아! 최대 힙이나 최소 힙을 만들어 정렬해. 시간 복잡도는 O(n log n)이고 선택 정렬의 더 효율적인 변형 같은 느낌이지. 큰 산더미를 만들고, 꼭대기에서부터 하나씩 내려오는 걸 생각해봐. 위에서부터 차례로 정리해 나가는 과정이야.\n"
		));

		String textPrompt = String.join("", Arrays.asList(
			"주어진 본문 텍스트는 다음과 같습니다.\n",
			"--------------------------------\n", text, "\n--------------------------------\n\n"
		));

		String cacheMessage = String.join("", Arrays.asList(
			systemPrompt,
			examplePrompt,
			text
		));

		String inputPrompt = String.join("", Arrays.asList(
			"이제 주어진 T, P, Q를 참고해서 SA, NA를 반환해 주세요:\n",
			"T: ", TContent, "\n",
			"P: ", PContent, "\n",
			"Q: ", QContent, "\n\n"
		));

		return CacheMessageContent.builder()
			.cacheMessage(cacheMessage)
			.userMessage(inputPrompt)
			.build();
	}

	public CacheMessageContent getCacheKeywordAnswerPrompt(String TContent, String PContent, String QContent,
		String keyword) {

		String systemPrompt = String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 키워드를 바탕으로 TPQ(Title, Point, Question)에 대한 답변을 작성하는 데 특화되어 있습니다. ",
			"반환 데이터는 각 질문(Q)에 대해 A(Answer)를 Simple, Normal의 세 가지 버전으로 작성해 주세요.\n\n",
			"이 형식으로 출력된 데이터는 사용자가 학습 내용을 단계적으로 깊이 이해하고 암기할 수 있도록 구성되어야 합니다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성해 주세요. ",
			"또한, 면접장에서 정답 답변을 말할 수 있도록 확실한 정답을 포함해 주세요.\n",
			"사용자가 암기하기 쉽도록 구성된 내용을 대화 형태로 전달하고, 중요한 주제와 개념을 포함하는 질문과 답변 형식으로 작성해 주세요.\n\n",

			"2가지 Answer 형식에 대해 다음과 같은 형식을 지킬 것:\n",
			getSimpleAnswerRequirements(),
			getNormalAnswerRequirements(),
			getCommonAnswerRequirements()
		));

		// 2. 예시 부분 (항상 동일)
		String examplePrompt = String.join("", Arrays.asList(
			"입력되는 TContent, Pcontent, Qcontent와 출력되어야 하는 SA, NA의 예시:\n",

			"\"T: 데이터 무결성 P: 데이터베이스 무결성 종류 Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\"일 때,\n",
			"SA: 개체 무결성! 참조 무결성!\n",
			"NA: 데이터베이스 무결성에는 개체 무결성과 참조 무결성이 있어! ‘개참’이라는 단어로 기억해봐. 개체는 고유함, 참조는 관계 유지라는 키워드를 기억해!! 개참개참~\n",
			"\"T: 데이터 무결성 P: 참조 무결성이란? Q: 참조 무결성에 대해서 설명해 주세요.\"일 때,\n",
			"SA: 외래 키는 기본 키 참조!\n",
			"NA: 참조 무결성은 외래 키가 다른 테이블의 기본 키를 반드시 참조해야 한다는 규칙이야. 부모와 자식의 관계처럼, 자식-외래 키는 반드시 부모-기본 키가 있어야 해. 부모가 있어야 자식이 존재할 수 있는 거랑 똑같아!\n",
			"\"T: 데이터 무결성 P: 참조 무결성 깨짐의 예시 Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\"일 때,\n",
			"SA: 참조 대상 기본 키 삭제했을 때!\n",
			"NA: 참조 무결성은 외래 키가 참조하는 기본 키가 삭제되면 깨져. 아이가 부모를 찾으려고 하는데 부모가 갑자기 사라지면 당황스럽겠지? 자식인 외래 키는 어디로 가야 할지 모르게 되고, 관계가 단절되는 거지.\n",
			"\"T: 암기 P: 단순 암기와 진정한 공부의 차이점 Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\"일 때,\n",
			"SA: 쉽게 잊혀지기 vs 이해하고 응용하며 오래 기억하기\n",
			"NA: 단순 암기는 반복해서 외우는 거고, 진정한 공부는 이해하고 응용하는 거야. 단순 암기는 쉽게 잊혀지지만, 진정한 공부는 오래 남게 돼. 단순 암기가 벽돌을 하나씩 쌓는 거라면, 진정한 공부는 그 벽돌로 집을 짓는 거야. 집을 지어야 벽돌들이 의미를 가지듯이, 전체적인 그림을 그리며 이해하는 게 중요해.\n",
			"\"T: 정렬 P: 버블 정렬 Q: 버블 정렬은 무엇인가요?\"일 때,\n",
			"SA: 인접 비교 후 교환! 거품처럼 느림!\n",
			"NA: 거품처럼 느리게 올라간다! 버블 정렬은 인접한 두 개를 비교하며 교환해. 시간 복잡도는 O(n²)이야. 느리지만 쉬운 방식이야. 거품이 버블버블 터지는 소리를 상상해봐! 두 수를 바꿀 때마다 버블이 하나씩 터지는 거야.\n",
			"\"T: 정렬 P: 선택 정렬 Q: 선택 정렬은 무엇인가요?\"일 때,\n",
			"SA: 가장 작은 값 선택! 맨 앞 정렬!\n",
			"NA: 선택해서 뽑는다! 가장 작은 값을 찾아서, 맨 앞에 두는 거야~! 시간 복잡도는 O(n²)이야. 반복해서 선택하며 정렬해. 사람들이 줄 서 있는 걸 생각해봐! 가장 작은 키의 사람을 선택!해서! 앞으로 계속 보내는 것처럼!\n",
			"\"T: 정렬 P: 삽입 정렬 Q: 삽입 정렬은 무엇인가요?\"일 때,\n",
			"SA: 카드처럼 적절한 위치에 삽입!\n",
			"NA: 삽입! 카드를 한 장씩 올바른 위치에 삽입하듯 정렬해. 거의 정렬된 배열에서는 빠르게 O(n)이고, 최악의 경우 O(n제곱)이야. 카드들을 처음 받았을 때, 보기 편하게 손에 들고 있는 카드를 하나씩 적절한 자리에 삽입하는 걸 생각해봐!!\n",
			"\"T: 정렬 P: 퀵 정렬 Q: 퀵 정렬은 무엇인가요?\"일 때,\n",
			"SA: 피벗 선택, 분할 정렬. 평균 O(n log n), 최악 O(n²)\n",
			"NA: 빠르게 퀵! 피벗을 선택해, 작은 건 왼쪽, 큰 건 오른쪽으로 나눠. 평균 시간 복잡도는 O(n log n)이고, 최악의 경우 O(n²)이지만 보통은 빠르지. 피벗이라는 큰! 바위가 물줄기를 나누는 것처럼 데이터를 나누는 거야.\n",
			"\"T: 정렬 P: 병합 정렬 Q: 병합 정렬은 무엇인가요?\"일 때,\n",
			"SA: 반으로 나눠 병합! 평균 O(n log n). 안정적\n",
			"NA: 병합! 반으로 쪼개고, 다시 병합해. 분할 정복으로 평균 O(n log n)이고 항상 안정적인 친구야. 종이를 반으로 접고 다시 펴는 것처럼, 데이터를 나누고, 그 안에서 정렬하고 다시 합치는 거야.\n",
			"\"T: 정렬 P: 힙 정렬 Q: 힙 정렬은 무엇인가요?\"일 때,\n",
			"SA: 힙 구조 정렬! 산더미 쌓기! 평균 O(n log n)\n",
			"NA: 힙을 쌓아! 최대 힙이나 최소 힙을 만들어 정렬해. 시간 복잡도는 O(n log n)이고 선택 정렬의 더 효율적인 변형 같은 느낌이지. 큰 산더미를 만들고, 꼭대기에서부터 하나씩 내려오는 걸 생각해봐. 위에서부터 차례로 정리해 나가는 과정이야.\n"
		));

		String textPrompt = String.join("", Arrays.asList(
			"이제 주어진 키워드를 참고해서 SA, NA를 반환해 주세요.\n",
			"--------------------------------\n", keyword, "\n--------------------------------\n\n"
		));

		String cacheMessage = String.join("", Arrays.asList(
			systemPrompt,
			examplePrompt,
			keyword
		));

		String inputPrompt = String.join("", Arrays.asList(
			"이제 주어진 T, P, Q를 참고해서 SA, NA를 반환해 주세요:\n",
			"T: ", TContent, "\n",
			"P: ", PContent, "\n",
			"Q: ", QContent, "\n\n"
		));

		return CacheMessageContent.builder()
			.cacheMessage(cacheMessage)
			.userMessage(inputPrompt)
			.build();
	}

	/**
	 * Simple 버전의 요구사항을 반환합니다.
	 */
	private String getSimpleAnswerRequirements() {

		return String.join("", Arrays.asList(
			"**Simple 버전(SA) 요구 사항**\n",
			"- 아주 짧고 간결한 문장으로 작성하여 정보만 전달하고, 불필요한 요소를 제외한 핵심 개념만을 명확하게 표현해 주세요.\n", //  명확하고 간결한 답변: 정보만 전달
			"- 'DML'에 대해서 질문했을 때, 'DML(Data Manipulation Language)!'로 답변하는 것처럼, 질문의 핵심 키워드 자체만을 답변하는 것은 지양해 주세요.\n",
			// 핵심 키워드만
			"- '~이다'나 '~ㄴ 것'이나 '단어'로 문장이 끝내어, 사용자가 빠르게 이해하고 기억할 수 있도록 해 주세요.\n\n" // 문어체 설정
		));
	}

	/**
	 * Normal 버전의 요구사항을 반환합니다.
	 */
	private String getNormalAnswerRequirements() {

		return String.join("", Arrays.asList(
			"**Normal 버전(NA) 요구 사항**\n",
			"- 핵심 개념을 조금 더 자세히, 명확하고 간결하게 설명해 주세요.\n", // 명확하고 간결한 답변
			"- 첫 문자 기법, 말뚝단어법, 이미지 연상법, 노래 기억법, 스토리 연상법, 마인드 맵핑법, 시각연상 기법, 벤다이어그램 기억법, 장소법 등의 연상기억법을 사용하는 것이 더 효과적이라고 판단된다면, 적절한 수준으로 사용해 주세요.\n",
			"- 청각, 시각, 촉각, 후각, 미각 등의 감각을 활용하는 것이 맥락상 더 효과적이라고 생각된다면, 적절한 수준으로 사용하여, 사용자가 더 쉽게 이해하고 기억할 수 있도록 설명해 주세요.\n",
			"- 각 개념을 일반적인 수준에서 쉽게 암기할 수 있도록 핵심 키워드를 반복 사용하며, 비유나 쉬운 예시를 활용하여 설명해 주세요.\n\n" // 반복과 예시 활용: 반복과 쉬운 예시
		));
	}

	/**
	 * 공통의 버전의 Answer 요구사항을 반환합니다.
	 */
	private String getCommonAnswerRequirements() {

		return String.join("", Arrays.asList(
			"**공통 요구 사항**\n",
			"- \"다른 표현 방식들\"과 같은 추가적인 표현 방식이나 \"작성 이유는 다음과 같습니다:\"와 같은 프롬프트 설명 멘트를 포함하여 반환하지 말아 주세요.\n",
			"- 영어 알파벳을 제외한 일본어, 중국어와 같은 외국어 및 한자 등을 포함하여 반환하지 말아 주세요.\n",
			"- SA와 NA를 기준으로, 하나의 개행문자(\\n)로 나누어 응답해 주세요.\n",
			"- 발음기호가 아닌 '-:=+/()@#$%^&*<>_'와 같은 특수기호 사용을 지향하면서, 사용자가 TTS로 들었을 때 이해하기 쉬운 리듬과 구조를 제공해주세요.\n\n"
		));
	}

	/**
	 * PDF 프롬프트의 요구사항을 반환합니다.
	 */
	public String getPdfImageTPQPrompt() {

		return String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 본문 텍스트를 명확하고 간결하게 요약하는 데 특화되어 있다. 주어진 본문을",
			" 읽고 사용자가 TTS로 듣기만 해도 학습적, 교육적, 암기적 효과를 얻을 수 있는 팟캐스트 형식의 TPQ 스크립트를 작성하라.\n\n",
			"반환 데이터는 T(Title), P(Point), Q(Question)로 구성된 QA 형식의 스크립트여야 하며, 이 형식은 학습과 암기에 효과적일 수 있도록 단순하고 명확하게 구성되어야 한다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성하라.",

			"각 질문은 간결하고 핵심적인 개념을 포함해야 하며, 암기 효과를 극대화하기 위해 반복과 중요 개념의 강조가 필요하다. ",
			"질문과 포인트는 사용자가 자연스럽게 연결될 수 있도록 구성하고, 각 주제에 대한 요점을 이해할 수 있도록 명확히 설정하라.\n\n",

			"TPQ 형식의 텍스트에 포함될 것:\n",
			"- 대제목(T): 각 대화의 주요 주제를 포괄적이지만 핵심적으로 나타낸다.\n",
			"- 포인트(P): 각 질문(Q)의 앞에서, 대화에서 다루는 세부 주제 및 키워드를 명확히 설정한다. 핵심 개념이 강조되도록 간결하게 작성할 것.\n",
			"- 질문(Q): 각 대화 주제에 대한 질문을 명확하고 간결하게 작성한다. 핵심 개념을 포함하며, 사용자가 쉽게 이해하고 기억할 수 있도록 구성한다.\n",

			"**공통 요구 사항**\n",
			"- 간결한 질문\n",
			"- 사용자가 TTS로 들을 때 이해하기 쉬운 리듬과 구조를 제공한다.\n", // 듣기 쉬운 대본
			"- 각 Q 앞에는 P로 시작하는 포인트를, 각 대화 주제 앞에는 T로 시작하는 타이틀을 사용하여, 주제를 명확히 설정한다. ",
			"이는 TTS로 제공될 때 사용자가 각 주제를 쉽게 이해하고 기억하도록 돕는다.\n", // 주제와 포인트 명확화
			"- 비슷한 주제의 질문은 반드시 하나의 T로 묶어주어야 한다. 즉, 질문은 반드시 하나의 T에 소속되어야 한다.\n",
			"- 영어 알파벳을 제외한 일본어, 중국어와 같은 외국어 및 한자 등을 포함하여 반환하지 말 것.\n",
			"- T와 P와 Q를 기준으로, 하나의 개행문자(\\n)로 나누어 응답할 것.\n",
			"- 사용자가 TTS로 들었을 때도 충분히 암기적 효과를 얻을 수 있도록 구성할 것.\n",
			"- 전체적인 형식은 학습적 가치를 극대화할 수 있도록 전체 흐름이 잘 정리되어야 하며, 사용자가 듣고 암기하기 쉬운 형태로 작성해야 한다.\n\n",
			"- \"다른 표현 방식들\"과 같은 추가적인 표현 방식이나 \"이 TPQ의 작성 이유는 다음과 같습니다:\"와 같은 프롬프트 설명 멘트를 포함하여 반환하지 말 것.\n",

			"대본의 예시:\n",
			"T: 데이터 무결성\n",
			"P: DBMS의 데이터 무결성 유지 방법\n",
			"Q: DBMS는 어떻게 데이터 무결성을 유지하나요?\n",
			"P: 데이터베이스 무결성 종류\n",
			"Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\n",
			"P: 참조 무결성이란?\n",
			"Q: 참조 무결성에 대해서 설명해 주세요.\n",
			"P: 참조 무결성 깨짐의 예시\n",
			"Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\n",
			"T: 암기\n",
			"P: 단순 암기와 진정한 공부의 차이점\n",
			"Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\n",

			"이제 주어진 PDF 또는 Image로 TPQ를 생성하라.\n",
			"T는 2개를 제공하고, 각각 PQ를 2개, 1개로 제공하라."
		));
	}

	/**
	 * TPQ에 해당하는 Answer를 2가지 버전으로 반환하는 프롬프트를 생성합니다.
	 */
	public String getAnswerPrompt(String TContent, String PContent, String QContent, String text) {

		// 1. 시스템 프롬프트 부분 (항상 동일)
		String systemPrompt = String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 본문 텍스트를 바탕으로 TPQ(Title, Point, Question)에 대한 답변을 작성하는 데 특화되어 있다. ",
			"반환 데이터는 각 질문(Q)에 대해 A(Answer)를 Simple, Normal의 세 가지 버전으로 작성해야 한다.\n\n",
			"이 형식으로 출력된 데이터는 사용자가 학습 내용을 단계적으로 깊이 이해하고 암기할 수 있도록 구성되어야 한다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성하라. 또한, 면접장에서 정답 답변을 말할 수 있도록 확실한 정답을 포함해야 한다.\n",
			"사용자가 암기하기 쉽도록 구성된 내용을 대화 형태로 전달하고, 중요한 주제와 개념을 포함하는 질문과 답변 형식으로 작성해야 한다.\n\n",

			"2가지 Answer 형식에 대해 다음과 같은 형식을 지킬 것:\n",
			getSimpleAnswerRequirements(),
			getNormalAnswerRequirements(),
			getCommonAnswerRequirements()
		));

		// 2. 예시 부분 (항상 동일)
		String examplePrompt = String.join("", Arrays.asList(
			"입력되는 TContent, Pcontent, Qcontent와 출력되어야 하는 SA, NA의 예시:\n",

			"\"T: 데이터 무결성 P: 데이터베이스 무결성 종류 Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\"일 때,\n",
			"SA: 개체 무결성! 참조 무결성!\n",
			"NA: 데이터베이스 무결성에는 개체 무결성과 참조 무결성이 있어! ‘개참’이라는 단어로 기억해봐. 개체는 고유함, 참조는 관계 유지라는 키워드를 기억해!! 개참개참~\n",
			"\"T: 데이터 무결성 P: 참조 무결성이란? Q: 참조 무결성에 대해서 설명해 주세요.\"일 때,\n",
			"SA: 외래 키는 기본 키 참조!\n",
			"NA: 참조 무결성은 외래 키가 다른 테이블의 기본 키를 반드시 참조해야 한다는 규칙이야. 부모와 자식의 관계처럼, 자식-외래 키는 반드시 부모-기본 키가 있어야 해. 부모가 있어야 자식이 존재할 수 있는 거랑 똑같아!\n",
			"\"T: 데이터 무결성 P: 참조 무결성 깨짐의 예시 Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\"일 때,\n",
			"SA: 참조 대상 기본 키 삭제했을 때!\n",
			"NA: 참조 무결성은 외래 키가 참조하는 기본 키가 삭제되면 깨져. 아이가 부모를 찾으려고 하는데 부모가 갑자기 사라지면 당황스럽겠지? 자식인 외래 키는 어디로 가야 할지 모르게 되고, 관계가 단절되는 거지.\n",
			"T: 암기 P: 단순 암기와 진정한 공부의 차이점 Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\"일 때,\n",
			"SA: 쉽게 잊혀지기 vs 이해하고 응용하며 오래 기억하기\n",
			"NA: 단순 암기는 반복해서 외우는 거고, 진정한 공부는 이해하고 응용하는 거야. 단순 암기는 쉽게 잊혀지지만, 진정한 공부는 오래 남게 돼. 단순 암기가 벽돌을 하나씩 쌓는 거라면, 진정한 공부는 그 벽돌로 집을 짓는 거야. 집을 지어야 벽돌들이 의미를 가지듯이, 전체적인 그림을 그리며 이해하는 게 중요해.\n",
			"T: 정렬 P: 버블 정렬 Q: 버블 정렬은 무엇인가요?\"일 때,\n",
			"SA: 인접 비교 후 교환! 거품처럼 느림!\n",
			"NA: 거품처럼 느리게 올라간다! 버블 정렬은 인접한 두 개를 비교하며 교환해. 시간 복잡도는 O(n²)이야. 느리지만 쉬운 방식이야. 거품이 버블버블 터지는 소리를 상상해봐! 두 수를 바꿀 때마다 버블이 하나씩 터지는 거야.\n",
			"T: 정렬 P: 선택 정렬 Q: 선택 정렬은 무엇인가요?\"일 때,\n",
			"SA: 가장 작은 값 선택! 맨 앞 정렬!\n",
			"NA: 선택해서 뽑는다! 가장 작은 값을 찾아서, 맨 앞에 두는 거야~! 시간 복잡도는 O(n²)이야. 반복해서 선택하며 정렬해. 사람들이 줄 서 있는 걸 생각해봐! 가장 작은 키의 사람을 선택!해서! 앞으로 계속 보내는 것처럼!\n",
			"T: 정렬 P: 삽입 정렬 Q: 삽입 정렬은 무엇인가요?\"일 때,\n",
			"SA: 카드처럼 적절한 위치에 삽입!\n",
			"NA: 삽입! 카드를 한 장씩 올바른 위치에 삽입하듯 정렬해. 거의 정렬된 배열에서는 빠르게 O(n)이고, 최악의 경우 O(n제곱)이야. 카드들을 처음 받았을 때, 보기 편하게 손에 들고 있는 카드를 하나씩 적절한 자리에 삽입하는 걸 생각해봐!!\n",
			"T: 정렬 P: 퀵 정렬 Q: 퀵 정렬은 무엇인가요?\"일 때,\n",
			"SA: 피벗 선택, 분할 정렬. 평균 O(n log n), 최악 O(n²)\n",
			"NA: 빠르게 퀵! 피벗을 선택해, 작은 건 왼쪽, 큰 건 오른쪽으로 나눠. 평균 시간 복잡도는 O(n log n)이고, 최악의 경우 O(n²)이지만 보통은 빠르지. 피벗이라는 큰! 바위가 물줄기를 나누는 것처럼 데이터를 나누는 거야.\n",
			"T: 정렬 P: 병합 정렬 Q: 병합 정렬은 무엇인가요?\"일 때,\n",
			"SA: 반으로 나눠 병합! 평균 O(n log n). 안정적\n",
			"NA: 병합! 반으로 쪼개고, 다시 병합해. 분할 정복으로 평균 O(n log n)이고 항상 안정적인 친구야. 종이를 반으로 접고 다시 펴는 것처럼, 데이터를 나누고, 그 안에서 정렬하고 다시 합치는 거야.\n",
			"T: 정렬 P: 힙 정렬 Q: 힙 정렬은 무엇인가요?\"일 때,\n",
			"SA: 힙 구조 정렬! 산더미 쌓기! 평균 O(n log n)\n",
			"NA: 힙을 쌓아! 최대 힙이나 최소 힙을 만들어 정렬해. 시간 복잡도는 O(n log n)이고 선택 정렬의 더 효율적인 변형 같은 느낌이지. 큰 산더미를 만들고, 꼭대기에서부터 하나씩 내려오는 걸 생각해봐. 위에서부터 차례로 정리해 나가는 과정이야.\n",
			"T: 정렬 P: 계수 정렬 Q: 계수 정렬은 무엇인가요?\"일 때,\n",
			"SA: 숫자 세고 위치 정하기! 범위 작을 때 유리! 평균 O(n)\n",
			"NA: 카운트! 범위가 작다면 O(n)으로 정렬할 수 있어. 숫자를 세어서 정렬하는 특별한 방식이야. 학생들이 줄 서서 하나씩 이름을 부르는 모습을 상상해봐! 각 값을 세어서 그 위치를 정하는 과정처럼.\n"
		));

		String textPrompt = String.join("", Arrays.asList(
			"주어진 본문 텍스트는 다음과 같습니다.\n",
			"--------------------------------\n", text, "\n--------------------------------\n\n"
		));

		String inputPrompt = String.join("", Arrays.asList(
			"이제 주어진 T, P, Q를 참고해서 SA, NA를 반환하세요:\n",
			"T: ", TContent, "\n",
			"P: ", PContent, "\n",
			"Q: ", QContent, "\n\n"
		));

		return String.join("", Arrays.asList(
			systemPrompt,
			examplePrompt,
			textPrompt,
			inputPrompt
		));
	}

	/**
	 * TPQ에 해당하는 Answer를 본문 없이 2가지 버전으로 반환하는 프롬프트를 생성합니다.
	 */
	public String getKeywordAnswerPrompt(String TContent, String PContent, String QContent, String keyword) {

		return String.join("", Arrays.asList(
			"당신은 자연어 처리의 전문가로서, 주어진 키워드를 바탕으로 TPQ(Title, Point, Question)에 대한 답변을 작성하는 데 특화되어 있다. ",
			"반환 데이터는 각 질문(Q)에 대해 A(Answer)를 Simple, Normal의 세 가지 버전으로 작성해야 한다.\n\n",
			"이 형식으로 출력된 데이터는 사용자가 학습 내용을 단계적으로 깊이 이해하고 암기할 수 있도록 구성되어야 한다. ",
			"사용자가 학습 내용을 쉽게 이해하고 기억할 수 있도록, 질문과 포인트가 명확히 드러나도록 작성하라. 또한, 면접장에서 정답 답변을 말할 수 있도록 확실한 정답을 포함해야 한다.\n",
			"사용자가 암기하기 쉽도록 구성된 내용을 대화 형태로 전달하고, 중요한 주제와 개념을 포함하는 질문과 답변 형식으로 작성해야 한다.\n\n",

			"2가지 Answer 형식에 대해 다음과 같은 형식을 지킬 것:\n",
			getSimpleAnswerRequirements(),
			getNormalAnswerRequirements(),
			getCommonAnswerRequirements(),

			"입력되는 TContent, Pcontent, Qcontent와 출력되어야 하는 SA, NA의 예시:\n",

			"\"T: 데이터 무결성 P: 데이터베이스 무결성 종류 Q: 데이터베이스에서 다루는 무결성의 주요 종류에는 어떤 것들이 있나요?\"일 때,\n",
			"SA: 개체 무결성! 참조 무결성!\n",
			"NA: 데이터베이스 무결성에는 개체 무결성과 참조 무결성이 있어! ‘개참’이라는 단어로 기억해봐. 개체는 고유함, 참조는 관계 유지라는 키워드를 기억해!! 개참개참~\n",
			"\"T: 데이터 무결성 P: 참조 무결성이란? Q: 참조 무결성에 대해서 설명해 주세요.\"일 때,\n",
			"SA: 외래 키는 기본 키 참조!\n",
			"NA: 참조 무결성은 외래 키가 다른 테이블의 기본 키를 반드시 참조해야 한다는 규칙이야. 부모와 자식의 관계처럼, 자식-외래 키는 반드시 부모-기본 키가 있어야 해. 부모가 있어야 자식이 존재할 수 있는 거랑 똑같아!\n",
			"\"T: 데이터 무결성 P: 참조 무결성 깨짐의 예시 Q: 참조 무결성이 깨지는 경우는 어떤 상황인가요?\"일 때,\n",
			"SA: 참조 대상 기본 키 삭제했을 때!\n",
			"NA: 참조 무결성은 외래 키가 참조하는 기본 키가 삭제되면 깨져. 아이가 부모를 찾으려고 하는데 부모가 갑자기 사라지면 당황스럽겠지? 자식인 외래 키는 어디로 가야 할지 모르게 되고, 관계가 단절되는 거지.\n",
			"T: 암기 P: 단순 암기와 진정한 공부의 차이점 Q: 단순 암기와 진정한 공부의 차이점은 무엇인가요?\"일 때,\n",
			"SA: 쉽게 잊혀지기 vs 이해하고 응용하며 오래 기억하기\n",
			"NA: 단순 암기는 반복해서 외우는 거고, 진정한 공부는 이해하고 응용하는 거야. 단순 암기는 쉽게 잊혀지지만, 진정한 공부는 오래 남게 돼. 단순 암기가 벽돌을 하나씩 쌓는 거라면, 진정한 공부는 그 벽돌로 집을 짓는 거야. 집을 지어야 벽돌들이 의미를 가지듯이, 전체적인 그림을 그리며 이해하는 게 중요해.\n",
			"T: 정렬 P: 버블 정렬 Q: 버블 정렬은 무엇인가요?\"일 때,\n",
			"SA: 인접 비교 후 교환! 거품처럼 느림!\n",
			"NA: 거품처럼 느리게 올라간다! 버블 정렬은 인접한 두 개를 비교하며 교환해. 시간 복잡도는 O(n²)이야. 느리지만 쉬운 방식이야. 거품이 버블버블 터지는 소리를 상상해봐! 두 수를 바꿀 때마다 버블이 하나씩 터지는 거야.\n",
			"T: 정렬 P: 선택 정렬 Q: 선택 정렬은 무엇인가요?\"일 때,\n",
			"SA: 가장 작은 값 선택! 맨 앞 정렬!\n",
			"NA: 선택해서 뽑는다! 가장 작은 값을 찾아서, 맨 앞에 두는 거야~! 시간 복잡도는 O(n²)이야. 반복해서 선택하며 정렬해. 사람들이 줄 서 있는 걸 생각해봐! 가장 작은 키의 사람을 선택!해서! 앞으로 계속 보내는 것처럼!\n",
			"T: 정렬 P: 삽입 정렬 Q: 삽입 정렬은 무엇인가요?\"일 때,\n",
			"SA: 카드처럼 적절한 위치에 삽입!\n",
			"NA: 삽입! 카드를 한 장씩 올바른 위치에 삽입하듯 정렬해. 거의 정렬된 배열에서는 빠르게 O(n)이고, 최악의 경우 O(n제곱)이야. 카드들을 처음 받았을 때, 보기 편하게 손에 들고 있는 카드를 하나씩 적절한 자리에 삽입하는 걸 생각해봐!!\n",
			"T: 정렬 P: 퀵 정렬 Q: 퀵 정렬은 무엇인가요?\"일 때,\n",
			"SA: 피벗 선택, 분할 정렬. 평균 O(n log n), 최악 O(n²)\n",
			"NA: 빠르게 퀵! 피벗을 선택해, 작은 건 왼쪽, 큰 건 오른쪽으로 나눠. 평균 시간 복잡도는 O(n log n)이고, 최악의 경우 O(n²)이지만 보통은 빠르지. 피벗이라는 큰! 바위가 물줄기를 나누는 것처럼 데이터를 나누는 거야.\n",
			"T: 정렬 P: 병합 정렬 Q: 병합 정렬은 무엇인가요?\"일 때,\n",
			"SA: 반으로 나눠 병합! 평균 O(n log n). 안정적\n",
			"NA: 병합! 반으로 쪼개고, 다시 병합해. 분할 정복으로 평균 O(n log n)이고 항상 안정적인 친구야. 종이를 반으로 접고 다시 펴는 것처럼, 데이터를 나누고, 그 안에서 정렬하고 다시 합치는 거야.\n",
			"T: 정렬 P: 힙 정렬 Q: 힙 정렬은 무엇인가요?\"일 때,\n",
			"SA: 힙 구조 정렬! 산더미 쌓기! 평균 O(n log n)\n",
			"NA: 힙을 쌓아! 최대 힙이나 최소 힙을 만들어 정렬해. 시간 복잡도는 O(n log n)이고 선택 정렬의 더 효율적인 변형 같은 느낌이지. 큰 산더미를 만들고, 꼭대기에서부터 하나씩 내려오는 걸 생각해봐. 위에서부터 차례로 정리해 나가는 과정이야.\n",
			// "T: 정렬 알고리즘의 기초 P: 정렬 알고리즘의 종류와 특징 Q: 대표적인 정렬 알고리즘의 종류와 각각의 특징을 설명해주세요.\"일 때,\n",

			"주어진 T, P, Q는 다음과 같다:\n",
			"T: ", TContent, "\n",
			"P: ", PContent, "\n",
			"Q: ", QContent, "\n\n",

			"이제 주어진 키워드를 참고해서 SA, NA를 반환하라.\n",
			"--------------------------------\n", keyword, "\n--------------------------------\n\n"
		));

	}

}
